<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Kloroplet Harita(√úlkeler i√ßin) Olu≈üturucu</title>
    

  </head>
    
  <body>
  <!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dinamik Kloroplet Haritasƒ± - Excel Destekli</title>
    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        crossorigin=""
    />
    <style>
        /* Ana D√ºzen */
        html, body {
            margin: 0; padding: 0; height: 100vh; width: 100vw; font-family: Arial, sans-serif;
            display: flex;
            overflow: hidden;
            background-color: #f4f4f4;
        }
        #map {
            flex-grow: 1;
            height: 100vh;
        }
        /* Saƒü Kenar √áubuƒüu (Sidebar) */
        #sidebar {
            width: 350px;
            background: #ffffff;
            border-left: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        h2 {
            font-size: 18px;
            margin-top: 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #007bff;
            color: #007bff;
        }
        h3 {
             font-size: 16px;
             margin-top: 15px;
             margin-bottom: 5px;
             color: #333;
        }
        /* Genel Form Elemanlarƒ± */
        .control-group, .layer-control-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 6px;
            background-color: #f8f9fa;
        }
        label {
            display: block;
            margin-top: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        .layer-control-group label {
            font-weight: normal;
        }
        input[type=color], select, button, .file-input-label {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
            box-sizing: border-box;
            cursor: pointer;
            text-align: center;
        }
        input[type=color] {
            height: 40px;
            cursor: pointer;
        }
        #applyColoring {
            background-color: #007bff;
            color: white;
            font-weight: bold;
            margin-top: 15px;
        }
        #applyColoring:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
        }

        /* Excel Kontrol Grubu */
        #excelControls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        #excelControls button {
            flex: 1;
            padding: 6px;
            font-size: 13px;
        }
        #fileUpload {
            display: none; /* Ger√ßek dosya inputunu gizle */
        }
        .file-input-label {
            background-color: #28a745;
            color: white;
            text-align: center;
            line-height: 1.5;
            padding: 8px 10px;
        }
        .file-input-label:hover {
            background-color: #1e7e34;
        }
        
        /* √úlke Veri Giri≈üi Alanƒ± */
        #dataInputContainer {
            max-height: 35vh; 
            overflow-y: auto;
            margin-top: 10px;
            padding-right: 5px;
        }
        .country-data-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            padding: 3px 0;
            border-bottom: 1px dotted #eee;
        }
        .country-data-item label {
            display: none; /* Label'lar gizlendi */
        }
        .country-data-item input[type=text],
        .country-data-item input[type=number] {
            padding: 4px;
            font-size: 13px;
            margin-top: 0;
            height: 28px;
            flex: 1;
        }
        .country-data-item input[type=text] {
            flex-basis: 60%;
            text-align: left;
            margin-right: 5px;
        }
        .country-data-item input[type=number] {
            flex-basis: 40%;
            text-align: right;
        }

        /* Lejant Stilleri */
        .legend {
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            font-size: 13px;
            line-height: 1.6;
        }
        .legend-title {
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
            border: 1px solid #999;
        }
        /* ƒ∞ndirme butonu stilini ekle */
        .leaflet-control-download {
            padding: 5px 10px;
            font-size: 14px;
            background-color: #ffc107;
            color: #333;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="sidebar">
        <h2>üìä Kloroplet Veri Giri≈üi</h2>

        <div class="control-group">
            <label for="colorPicker">Ana Renk Se√ßimi (Gradyan Temeli):</label>
            <input type="color" id="colorPicker" value="#007bff" />

            <label for="gradientType">Gradyan Y√∂n√º (Renklendirme Tipi):</label>
            <select id="gradientType">
                <option value="highToLow">Y√ºksek Veri ‚Üí Yoƒüun Renk (Artan)</option>
                <option value="lowToHigh">Al√ßak Veri ‚Üí Yoƒüun Renk (Azalan)</option>
            </select>

            <button id="applyColoring" disabled>‚úÖ Haritayƒ± Renklendir</button>
        </div>

        <h3>Veri Y√∂netimi (Excel)</h3>
        <div id="excelControls">
            <button id="downloadExcel">‚¨áÔ∏è Excel ≈ûablonu ƒ∞ndir</button>
            <input type="file" id="fileUpload" accept=".xlsx" />
            <label for="fileUpload" class="file-input-label">‚¨ÜÔ∏è Excel Y√ºkle</label>
        </div>

        <h3>√úlke ƒ∞simleri ve Verileri</h3>
        <div id="dataInputContainer">
            <div style="text-align: center; font-style: italic; color: #555;">... Y√ºkleniyor ...</div>
        </div>

        <div class="layer-control-group">
            <label>Harita G√∂r√ºn√ºm√º Se√ßenekleri:</label>
            <div>
                <input type="radio" id="osmBasemap" name="basemap" checked />
                <label for="osmBasemap">OpenStreetMap Altlƒ±k</label>
            </div>
            <div>
                <input type="radio" id="grayBorders" name="basemap" />
                <label for="grayBorders">Renkli GeoJSON + Gri Sƒ±nƒ±rlar</label>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

    <script>
        const map = L.map('map').setView([20, 0], 2);

        const polygonsGroup = L.layerGroup().addTo(map);

        const osmTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        let grayBordersLayer = null;

        const dataInputContainer = document.getElementById('dataInputContainer');
        const colorPicker = document.getElementById('colorPicker');
        const gradientType = document.getElementById('gradientType');
        const applyColoringButton = document.getElementById('applyColoring');
        const downloadExcelButton = document.getElementById('downloadExcel');
        const fileUploadInput = document.getElementById('fileUpload');

        let countriesGeoJSON = null;
        let geojsonFeatureOrder = [];
        let countryData = {};

        // --- Lejant Kontrol√º ---
        const legendControl = L.Control.extend({
            options: { position: 'bottomright' },
            onAdd: function (map) {
                this._div = L.DomUtil.create('div', 'info legend');
                this._div.id = 'legendContainer';
                L.DomEvent.disableClickPropagation(this._div);
                return this._div;
            }
        });
        map.addControl(new legendControl());
        const legendContainer = document.getElementById('legendContainer');

        // --- Harita ƒ∞ndirme Kontrol√º ---
        const DownloadControl = L.Control.extend({
            options: { position: 'bottomleft' },
            onAdd: function (map) {
                const button = L.DomUtil.create('button', 'leaflet-control-download');
                button.id = 'snapshotButton';
                button.innerHTML = '‚úÇÔ∏è Ekran Alƒ±ntƒ±sƒ± ƒ∞√ßin Tƒ±kla';
                L.DomEvent.on(button, 'click', () => {
                    alert(
                        "Harita g√∂r√ºnt√ºs√ºn√º almak i√ßin l√ºtfen tarayƒ±cƒ±nƒ±zƒ±n veya i≈ületim sisteminizin ekran alƒ±ntƒ±sƒ± (screenshot) aracƒ±nƒ± kullanƒ±n.\n\n" +
                        "Kƒ±sayollar:\n" +
                        "Windows: Shift + Windows Tu≈üu + S\n" +
                        "macOS: Shift + Command (‚åò) + 4"
                    );
                });
                L.DomEvent.disableClickPropagation(button);
                return button;
            }
        });
        map.addControl(new DownloadControl());

        // Yardƒ±mcƒ± Fonksiyonlar
        function getCountryName(feature) {
            return (feature.properties.ADMIN || feature.properties.NAME || feature.properties.name || "Bilinmeyen").trim();
        }

        function getColorForValue(value, min, max, baseColor, type) {
            if (isNaN(value) || value === null) { return '#ccc'; }
            if (min === max) { return baseColor; }

            const normalizedValue = (value - min) / (max - min);
            const darkColor = chroma(baseColor).darken(1.5).hex();
            const lightColor = chroma(baseColor).brighten(1.5).hex();
            let colorScale = chroma.scale([lightColor, baseColor, darkColor]).domain([0, 0.5, 1]);

            if (type === 'lowToHigh') {
                return colorScale(1 - normalizedValue).hex(); 
            }
            return colorScale(normalizedValue).hex();
        }

        function formatNumber(num) {
            num = parseFloat(num);
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + ' Mr.';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1).replace(/\.0$/, '') + ' M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(0).replace(/\.0$/, '') + ' K';
            }
            return num.toLocaleString('tr-TR', { maximumFractionDigits: 0 }); 
        }

        function updateLegend(minVal, maxVal, baseColor, type) {
            legendContainer.innerHTML = '<div class="legend-title">Deƒüer Aralƒ±ƒüƒ±</div>';

            const grades = [minVal];
            const range = maxVal - minVal;
            const numGrades = 5; 
            
            for(let i = 1; i < numGrades; i++) {
                grades.push(minVal + (range / numGrades) * i);
            }
            grades.push(maxVal);

            for (let i = 0; i < numGrades; i++) {
                const from = grades[i];
                const to = grades[i+1];

                const midValue = (from + to) / 2;
                const color = getColorForValue(midValue, minVal, maxVal, baseColor, type);

                legendContainer.innerHTML +=
                    '<div><i style="background:' + color + ';"></i> ' +
                    formatNumber(from) + (i < numGrades - 1 ? '&ndash;' + formatNumber(to) : ' +') +
                    '</div>';
            }
                
            legendContainer.innerHTML += '<div><i style="background:#ccc;"></i> Veri Yok / Tanƒ±msƒ±z</div>';
        }

        function downloadCountryDataExcel() {
            if (!countriesGeoJSON) {
                alert("GeoJSON verisi hen√ºz y√ºklenmedi. L√ºtfen bekleyin.");
                return;
            }

            const dataForExcel = geojsonFeatureOrder.map(originalId => {
                const currentData = countryData[originalId] || {};
                
                return {
                    '√úLKE_ADI_HARƒ∞TA': currentData.displayName || originalId,
                    'MATEMATƒ∞KSEL_DEƒûER': currentData.dataValue || '' 
                };
            });

            const ws = XLSX.utils.json_to_sheet(dataForExcel);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "VeriGiri≈üi");

            XLSX.writeFile(wb, "Kloroplet_Veri_Sablonu.xlsx");
        }

        function handleExcelUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = new Uint8Array(event.target.result);
                    const workbook = XLSX.read(data, { type: 'array', raw: false }); 
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false }); 
                    
                    if (json.length < 2) {
                        alert("Excel dosyasƒ± bo≈ü veya ba≈ülƒ±k satƒ±rƒ± eksik.");
                        return;
                    }

                    const headers = json[0].map(h => (h || '').toString().trim());
                    const countryColIndex = headers.indexOf('√úLKE_ADI_HARƒ∞TA');
                    const dataColIndex = headers.indexOf('MATEMATƒ∞KSEL_DEƒûER');

                    if (countryColIndex === -1 || dataColIndex === -1) {
                        alert("Hatalƒ± Excel formatƒ±. S√ºtun ba≈ülƒ±klarƒ± '√úLKE_ADI_HARƒ∞TA' ve 'MATEMATƒ∞KSEL_DEƒûER' olmalƒ±dƒ±r.");
                        return;
                    }
                    
                    let newCountryData = {};
                    let warningCount = 0;
                    
                    for (let i = 1; i < json.length; i++) {
                        const row = json[i];
                        const excelDisplayName = (row[countryColIndex] || '').toString().trim();
                        const rawDataValue = (row[dataColIndex] || '').toString();

                        let cleanDataValue = rawDataValue.trim();
                        cleanDataValue = cleanDataValue.replace(/\./g, ''); 
                        cleanDataValue = cleanDataValue.replace(/,/g, '.');
                        const excelDataValue = parseFloat(cleanDataValue);

                        const originalId = geojsonFeatureOrder[i-1];

                        if (originalId) {
                             const dataVal = !isNaN(excelDataValue) ? excelDataValue : undefined;
                             const displayN = excelDisplayName || originalId;
                            
                             newCountryData[originalId] = {
                                 dataValue: dataVal,
                                 displayName: displayN
                             };
                        } else {
                             warningCount++;
                        }
                    }

                    if (warningCount > 0) {
                        console.warn(`Excel dosyasƒ±nda GeoJSON'da bulunmayan ${warningCount} satƒ±r atlandƒ±.`);
                    }

                    countryData = newCountryData;
                    populateDataInputs(); 
                    applyColoringButton.disabled = Object.keys(countryData).length === 0;
                    alert("Excel verileri ba≈üarƒ±yla y√ºklendi. Haritayƒ± renklendirmek i√ßin butona tƒ±klayƒ±n.");

                } catch (error) {
                    console.error("Excel y√ºklenirken hata:", error);
                    alert("Excel dosyasƒ± i≈ülenirken bir hata olu≈ütu. Dosya formatƒ±nƒ± kontrol edin.");
                } finally {
                    e.target.value = ''; 
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function populateDataInputs() {
            if (!countriesGeoJSON) return;

            dataInputContainer.innerHTML = '';
            
            geojsonFeatureOrder.forEach(originalId => {
                const currentData = countryData[originalId] || { dataValue: '', displayName: originalId };
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'country-data-item';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = currentData.displayName; 
                nameInput.placeholder = originalId;
                nameInput.title = `Orijinal Ad: ${originalId}`;
                nameInput.setAttribute('data-original-id', originalId);

                nameInput.addEventListener('input', (e) => {
                    const newName = e.target.value.trim() || originalId;
                    if (!countryData[originalId]) {
                        countryData[originalId] = { dataValue: undefined, displayName: newName };
                    } else {
                        countryData[originalId].displayName = newName;
                    }
                    applyColoringButton.disabled = Object.values(countryData).every(d => d.dataValue === undefined);
                });

                const dataInput = document.createElement('input');
                dataInput.type = 'number';
                dataInput.step = 'any';
                dataInput.placeholder = 'Veri';
                dataInput.value = currentData.dataValue !== undefined ? currentData.dataValue : '';
                dataInput.setAttribute('data-original-id', originalId);

                dataInput.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    const currentName = nameInput.value.trim() || originalId;
                    
                    if (!isNaN(val)) {
                         countryData[originalId] = { 
                            dataValue: val, 
                            displayName: currentName 
                          };
                    } else {
                        countryData[originalId] = { 
                            dataValue: undefined, 
                            displayName: currentName 
                        };
                    }
                    applyColoringButton.disabled = Object.values(countryData).every(d => d.dataValue === undefined);
                });

                itemDiv.appendChild(nameInput);
                itemDiv.appendChild(dataInput);
                dataInputContainer.appendChild(itemDiv);
            });

             applyColoringButton.disabled = Object.values(countryData).every(d => d.dataValue === undefined);
        }

        function applyChoroplethColoring() {
            if (!countriesGeoJSON) return;

            const validDataPoints = Object.values(countryData).filter(d => d.dataValue !== undefined && !isNaN(d.dataValue));
            const dataValues = validDataPoints.map(d => d.dataValue);

            if (dataValues.length === 0) {
                alert("L√ºtfen en az bir √ºlke i√ßin matematiksel veri girin veya y√ºkleyin.");
                polygonsGroup.clearLayers();
                legendContainer.innerHTML = '<div class="legend-title">Veri Girin veya Excel Y√ºkleyin</div>';
                return;
            }

            const minVal = Math.min(...dataValues);
            const maxVal = Math.max(...dataValues);
            const baseColor = colorPicker.value;
            const type = gradientType.value;

            polygonsGroup.clearLayers();

            L.geoJSON(countriesGeoJSON, {
                style: (feature) => {
                    const originalId = getCountryName(feature);
                    const dataEntry = countryData[originalId] || {};
                    const value = dataEntry.dataValue;
                    const fillColor = getColorForValue(value, minVal, maxVal, baseColor, type);

                    return {
                        fillColor: fillColor,
                        color: 'gray',
                        weight: 1.5,
                        opacity: 1,
                        fillOpacity: (value !== undefined && !isNaN(value)) ? 0.8 : 0.3,
                        dashArray: ''
                    };
                },
                onEachFeature: (feature, layer) => {
                    const originalId = getCountryName(feature);
                    const dataEntry = countryData[originalId] || {};
                    const displayName = dataEntry.displayName || originalId;
                    const value = dataEntry.dataValue;

                    function formatValueForTooltip(v) {
                        if (v === undefined || isNaN(v)) return 'Veri Yok';
                        return v.toLocaleString('tr-TR', { maximumFractionDigits: 0 });
                    }

                    const tooltipText = `<b>${displayName}</b>: ${formatValueForTooltip(value)}`;
                    layer.bindTooltip(tooltipText, { permanent: false, direction: "auto" });
                }
            }).addTo(polygonsGroup);

            updateLegend(minVal, maxVal, baseColor, type);
        }

        function updateMapLayers(selection) {
            if (selection === 'osmBasemap') {
                if (!map.hasLayer(osmTileLayer)) map.addLayer(osmTileLayer);
                if (grayBordersLayer && map.hasLayer(grayBordersLayer)) map.removeLayer(grayBordersLayer);
                if (!map.hasLayer(polygonsGroup)) map.addLayer(polygonsGroup);
            } else if (selection === 'grayBorders') {
                if (map.hasLayer(osmTileLayer)) map.removeLayer(osmTileLayer);

                if (countriesGeoJSON && !grayBordersLayer) {
                    grayBordersLayer = L.geoJSON(countriesGeoJSON, {
                        style: {
                            fillColor: '#F5F5F5',
                            color: '#B0B0B0',
                            weight: 0.5,
                            opacity: 1,
                            fillOpacity: 1,
                        },
                        onEachFeature: (feature, layer) => {
                            layer.options.interactive = false;
                            layer.off('click');
                        }
                    }).addTo(map);
                    polygonsGroup.bringToFront();
                }
                if (grayBordersLayer && !map.hasLayer(grayBordersLayer)) {
                    map.addLayer(grayBordersLayer);
                }
                if (!map.hasLayer(polygonsGroup)) map.addLayer(polygonsGroup);
            }
        }

        document.querySelectorAll('input[name="basemap"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                updateMapLayers(e.target.id);
            });
        });

        applyColoringButton.addEventListener('click', applyChoroplethColoring);
        downloadExcelButton.addEventListener('click', downloadCountryDataExcel);
        fileUploadInput.addEventListener('change', handleExcelUpload);
        colorPicker.addEventListener('change', () => applyColoringButton.disabled = Object.values(countryData).every(d => d.dataValue === undefined));
        gradientType.addEventListener('change', () => applyColoringButton.disabled = Object.values(countryData).every(d => d.dataValue === undefined));

        // GeoJSON y√ºkleme
        fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson')
            .then(res => res.json())
            .then(data => {
                countriesGeoJSON = data;
                geojsonFeatureOrder = countriesGeoJSON.features.map(f => getCountryName(f));
                populateDataInputs();
                updateMapLayers('osmBasemap');
                legendContainer.innerHTML = '<div class="legend-title">Veri Girin veya Excel Y√ºkleyin</div>';
            })
            .catch(err => {
                console.error("GeoJSON y√ºklenirken hata:", err);
                dataInputContainer.innerHTML = "<p style='color:red;'>Harita verisi y√ºklenemedi.</p>";
                legendContainer.innerHTML = '<div class="legend-title" style="color:red;">Hata: Harita Verisi Yok</div>';
            });
    </script>
</body>
</html>
    
  </body>
  
</html>
